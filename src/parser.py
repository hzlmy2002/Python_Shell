from parsita import *
from appfactory import AppNotFoundError, appFactory
from commandtree import Argument, InRedirection, OutRedirection, Call, Seq
from apps.App import App
from itertools import chain


class CommandParsers(TextParsers, whitespace=None):
    singleQuoted = "'" >> reg(r"[^\n\r']*") << "'"
    backQuoted = "`" >> reg(r"[^\n\r`]*") << "`"
    doubleQuoted = (
        '"' >> rep("`" & reg(r"[^\n\r`]*") & "`" | reg(r"[^\n\r\"`]+")) << '"' > "".join
    )  # concatenate list returned by rep() into single quote string
    quoted = singleQuoted | backQuoted | doubleQuoted

    unquoted = reg(r"[^\s'\"`;|<>]*")

    argument = (quoted | unquoted) > Argument

    whitespace = reg(r"[ \t]+")
    inRedirection = (">" >> whitespace >> argument) > InRedirection
    outRedirection = ("<" >> whitespace >> argument) > OutRedirection
    redirection = inRedirection | outRedirection

    atom = argument | redirection

    def getApp(appName: str) -> Parser[str, "App"]:
        try:
            app = appFactory(appName)
            return success(app)
        except AppNotFoundError:
            return failure(f"Application {appName} not found.")

    def makeCall(params):
        app = params[0]

        # remove empty lists and merge sublists generated by combinator
        redirections = params[1]
        arg = params[2]
        atoms = params[3]
        mergedParams = redirections + [arg] + atoms

        return Call(app, mergedParams)

    call = (
        (opt(whitespace) >> (unquoted >= getApp))
        & (whitespace >> rep(redirection << whitespace))
        & argument
        & rep(whitespace >> atom) << opt(whitespace)
    ) > makeCall

    command = rep1sep(call, ";") > Seq


if __name__ == "__main__":
    command = CommandParsers.command.parse("echo hello world").or_die()
    call = command.getCommands()[0]
    print(call.getApp())
    print(call.getParams())
